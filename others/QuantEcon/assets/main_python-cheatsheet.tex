\title{QuantEcon -- Python Cheatsheet}

\section{Functions -- Part 1}\label{functions_pt1}

\begin{tabular}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.17\columnwidth}\raggedright
Command
\end{minipage} & \begin{minipage}[b]{0.77\columnwidth}\raggedright
Description
\end{minipage}\tabularnewline
\midrule
\begin{minipage}[t]{0.17\columnwidth}\raggedright
\lstinline!*!
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright
multiplication operation: \lstinline!2*3! returns \lstinline!6!
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright
\lstinline!**!
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright
power operation: \lstinline!2**3! returns \lstinline!8!
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright
\lstinline!@!
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright
matrix multiplication:

\begin{lstlisting}[language=Python]
import numpy as np
A = np.array([[1,2,3]])
B = np.array([[3],[2],[1]])
A @ B
\end{lstlisting}

returns

\begin{lstlisting}[language=Python]
array([[10]])
\end{lstlisting}

\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright
\lstinline!lambda!
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright
Used for create anonymous one line functions of the form:

\begin{lstlisting}[language=Python]
f = lambda x,y: 5*x+y
\end{lstlisting}

The code after the lambda but before variables specifies the parameters.
The code after the colon tells python what object to return.
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright
\lstinline!def!
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright
The def command is used to create functions of more than one line:

\begin{lstlisting}[language=Python]
def g(x,y):
    """
    Docstring
    """
    ret = sin(x)
    return ret + y
\end{lstlisting}

The code immediately following \lstinline!def! names the function, in
this example \lstinline!g! . The variables in the parenthesis are the
parameters of the function. The remaining lines of the function are
denoted by tab indents. The return statement specifies the object to be
returned.
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright
\lstinline!len(iterable)!
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright
\lstinline!len! is a function that takes an iterable, such as a list,
tuple or numpy array and returns the number of items in that object. For
a numpy array, \lstinline!len! returns the length of the outermost
dimension

\begin{lstlisting}[language=Python]
len(np.zeros((5,4)))
\end{lstlisting}

returns \lstinline!5!.


\end{minipage}\tabularnewline
\bottomrule
\end{tabular}

\section{Functions -- Part 2}\label{functions_pt2}

\begin{tabular}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.17\columnwidth}\raggedright
Command
\end{minipage} & \begin{minipage}[b]{0.77\columnwidth}\raggedright
Description
\end{minipage}\tabularnewline
\midrule

\begin{minipage}[t]{0.17\columnwidth}\raggedright
\lstinline!l = [a1,a2,...,an]!
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright
Constructs a list containing the objects \(a1,a2,...,an\). You can
append to the list using \lstinline!l.append()!. The \(ith\) element of
\(l\) can be accessed using \lstinline!l[i]!
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright
\lstinline!t =(a1,a2,...,an)!
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright
Constructs a tuple containing the objects \(a1,a2,...,an\). The \(ith\)
element of \(t\) can be accessed using \lstinline!t[i]!
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright
\lstinline!for a in iterable:!
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright
For loop used to perform a sequence of commands (denoted using tabs) for
each element in an iterable object such as a list, tuple, or numpy
array. An example code is

\begin{lstlisting}[language=Python]
l  = []
for i in [1,2,3]:
    l.append(i**2)
print(l)
\end{lstlisting}

prints \lstinline![1,4,9]!
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright
\lstinline!if condition:!
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright
Performs code if a condition is met (using tabs). For example

\begin{lstlisting}[language=Python]
if x == 5:
    x = x**2
else:
    x = x**3
\end{lstlisting}

squares \(x\) if \(x\) is \(5\), otherwise cubes it.
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright
\lstinline!zip!
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright
Make an iterator that aggregates elements from each of the iterables.

\begin{lstlisting}[language=Python]
x = [1, 2, 3]
y = [4, 5, 6]
zipped = zip(x, y)
list(zipped)
\end{lstlisting}

returns \lstinline![(1, 4), (2, 5), (3, 6)]!
\end{minipage}\tabularnewline
\bottomrule
\end{tabular}

\section{Functions -- Part 3}\label{functions_pt3}

\begin{tabular}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.17\columnwidth}\raggedright
Command
\end{minipage} & \begin{minipage}[b]{0.77\columnwidth}\raggedright
Description
\end{minipage}\tabularnewline
\midrule

\begin{minipage}[t]{0.17\columnwidth}\raggedright
\lstinline!plt.plot(x,y,s =None)!
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright
The plot command is included in \lstinline!matplotlib.pyplot!. The plot
command is used to plot \(x\) versus \(y\) where \(x\) and \(y\) are
iterables of the same length. By default the plot command draws a line,
using the \(s\) argument you can specify type of line and color. For
example `-','- -`,':`,'o','x', and `-o' reprent line, dashed line,
dotted line, circles, x's, and circle with line through it respectively.
Color can be changed by appending `b','k','g' or `r', to get a blue,
black, green or red plot respectively. For example,

\begin{lstlisting}[language=Python]
import numpy as np
import matplotlib.pyplot as plt
x=np.linspace(0,10,100)
N=len(x)
v= np.cos(x)
plt.figure(1)
plt.plot(x,v,'-og')
plt.show()
plt.savefig('tom_test.eps')
\end{lstlisting}

plots the cosine function on the domain (0,10) with a green line with
circles at the points \(x,v\)
\end{minipage}\tabularnewline
\bottomrule
\end{tabular}

\section{Numpy Arrays -- Part 1}\label{numpy-arrays_pt1}

\begin{tabular}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.22\columnwidth}\raggedright
Command
\end{minipage} & \begin{minipage}[b]{0.72\columnwidth}\raggedright
Description
\end{minipage}\tabularnewline
\midrule
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\lstinline!np.array(object,dtype = None)!
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright
\lstinline!np.array! constructs a numpy array from an object, such as a
list or a list of lists. \lstinline!dtype! allows you to specify the
type of object the array is holding. You will generally note need to
specify the \lstinline!dtype!. Examples:

\begin{lstlisting}[language=Python]
np.array([1, 2, 3]) #creates 1 dim array of ints
np.array( [1,2,3.0] )#creates 1 dim array of floats
np.array( [ [1,2],[3,4] ]) #creates a 2 dim array
\end{lstlisting}

\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\lstinline!A[i1,i2,...,in]!
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright
Access a the element in numpy array A in with index i1 in dimension 1,
i2 in dimension 2, etc. Can use \lstinline!:! to access a range of
indices, where \lstinline!imin:imax! represents all \(i\) such that
\(imin \leq i < imax\). Always returns an object of minimal dimension.
For example,

\lstinline!A[:,2]!

returns the 2nd column (counting from 0) of A as a 1 dimensional array
and

\lstinline!A[0:2,:]!

returns the 0th and 1st rows in a 2 dimensional array.
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\lstinline!np.zeros(shape)!
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright
Constructs numpy array of shape shape. Here shape is an integer of
sequence of integers. Such as 3, (1,2),(2,1), or (5,5). Thus

\lstinline!np.zeros((5,5))!

Constructs an \(5\times 5\) array while

\lstinline!np.zeros(5,5)!

will throw an error.
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\lstinline!np.ones(shape)!
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright
Same as \lstinline!np.zeros! but produces an array of ones
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\lstinline!np.linspace(a,b,n)!
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright
Returns a numpy array with \(n\) linearly spaced points between \(a\)
and \(b\). For example

\lstinline!np.linspace(1,2,10)!

returns

\begin{lstlisting}[language=Python]
array([ 1.        ,  1.11111111,  1.22222222,  1.33333333,
1.44444444, 1.55555556,  1.66666667,  1.77777778,
1.88888889,  2.        ])
\end{lstlisting}

\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\lstinline!np.eye(N)!
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright
Constructs the identity matrix of size \(N\). For example

\lstinline!np.eye(3)!

returns the \(3\times 3\) identity matrix:

\[\left(\begin{matrix}1&0&0\\0&1&0\\ 0&0&1\end{matrix}\right)\]
\end{minipage}\tabularnewline
\bottomrule
\end{tabular}

\section{Numpy Arrays -- Part 2}\label{numpy-arrays_pt2}

\begin{tabular}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.22\columnwidth}\raggedright
Command
\end{minipage} & \begin{minipage}[b]{0.72\columnwidth}\raggedright
Description
\end{minipage}\tabularnewline
\midrule

\begin{minipage}[t]{0.22\columnwidth}\raggedright
\lstinline!np.diag(a)!
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright
\lstinline!np.diag! has 2 uses. First if \lstinline!a! is a 2
dimensional array then \lstinline!np.diag! returns the principle
diagonal of the matrix. Thus

\lstinline!np.diag( [ [1,3], [5,6] ])!

returns \lstinline![1,6]!.

If \(a\) is a 1 dimensional array then \lstinline!np.diag! constructs an
array with \$a\$ as the principle diagonal. Thus,

\lstinline!np.diag([1,2])!

returns

\[\left(\begin{matrix}1&0\\0&2\end{matrix}\right)\]
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\lstinline!np.random.rand(d0, d1, ..., dn)!
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright
Constructs a numpy array of shape \lstinline!(d0,d1,...,dn)! filled with
random numbers drawn from a uniform distribution between :math`(0,1).
For example, :python:np.random.rand(2,3)` returns

\begin{lstlisting}[language=Python]
array([[ 0.69060674,  0.38943021,  0.19128955],
[ 0.5419038 ,  0.66963507,  0.78687237]])
\end{lstlisting}

\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\lstinline!np.random.randn(d0, d1, ..., dn)!
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright
Same as \lstinline!np.random.rand(d0, d1, ..., dn)! except that it draws
from the standard normal distribution \(\mathcal N(0,1)\) rather than
the uniform distribution.
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\lstinline!A.T!
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright
Reverses the dimensions of an array (transpose). For example, if
\(x = \left(\begin{matrix} 1& 2\\3&4\end{matrix}\right)\) then
\lstinline!x.T! returns
\(\left(\begin{matrix} 1& 3\\2&4\end{matrix}\right)\)
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\lstinline!np.amax(a, axis = None)!
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright
By default \lstinline!np.amax(a)! finds the maximum of all elements in
the array \(a\). Can specify maximization along a particular dimension
with axis. If

\lstinline!a = np.array( [ [2,1], [3,4] ]) #creates a 2 dim array!

then

\lstinline!np.amax(a,axis = 0) #maximization along row (dim 0)!

returns \lstinline!array([3,4])! and

\lstinline!np.amax(a, axis = 1) #maximization along column (dim 1)!

returns \lstinline!array([2,4])!
\end{minipage}\tabularnewline

\begin{minipage}[t]{0.22\columnwidth}\raggedright
\lstinline!np.argmax(a, axis = None)!
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright
Performs similar function to np.amax except returns index of maximal
element. By default gives index of flattened array, otherwise can use
axis to specify dimension. From the example for np.amax

\begin{lstlisting}[language=Python]
np.amax(a,axis = 0) #maximization along row (dim 0)
\end{lstlisting}

returns \lstinline!array([1,1])! and

\begin{lstlisting}[language=Python]
np.amax(a, axis = 1) #maximization along column (dim 1)
\end{lstlisting}

returns \lstinline!array([0,1])!
\end{minipage}\tabularnewline


\bottomrule
\end{tabular}

\section{Numpy Arrays -- Part 3}\label{numpy-arrays_pt3}

\begin{tabular}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.22\columnwidth}\raggedright
Command
\end{minipage} & \begin{minipage}[b]{0.72\columnwidth}\raggedright
Description
\end{minipage}\tabularnewline
\midrule

\begin{minipage}[t]{0.22\columnwidth}\raggedright
\lstinline!np.hstack(tuple)!
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright
Take a sequence of arrays and stack them horizontally to make a single
array. For example

\begin{lstlisting}[language=Python]
a = np.array(( [1,2,3] )
b = np.array( [2,3,4] )
np.hstack( (a,b) )
\end{lstlisting}

returns \lstinline![1,2,3,2,3,4]! while

\begin{lstlisting}[language=Python]
a = np.array( [[1],[2],[3]] )
b = np.array( [[2],[3],[4]] )
np.hstack((a,b))
\end{lstlisting}

returns
\(\left( \begin{matrix} 1&2\\2&3\\ 3&4 \end{matrix}\right)\)
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright
\lstinline!np.vstack(tuple)!
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright
Like \lstinline!np.hstack!. Takes a sequence of arrays and stack them
vertically to make a single array. For example

\begin{lstlisting}[language=Python]
a = np.array( [1,2,3] )
b = np.array( [2,3,4] )
np.hstack( (a,b) )
\end{lstlisting}

returns

\begin{lstlisting}[language=Python]
array( [ [1,2,3],
[2,3,4] ] )
\end{lstlisting}

\end{minipage}\tabularnewline

\begin{minipage}[t]{0.22\columnwidth}\raggedright
\lstinline!np.dot(a,b)! or \lstinline!a.dot(b)!
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright
Returns an array equal to the dot product of \(a\) and \(b\). For this
operation to work the innermost dimension of \(a\) must be equal to the
outermost dimension of \(b\). If \(a\) is a \((3,2)\) array and \(b\) is
a \((2)\) array then \lstinline!np.dot(a,b)! is valid. If \(b\) is a
\((1,2)\) array then the operation will return an error.
\end{minipage}\tabularnewline

\bottomrule
\end{tabular}

\section{numpy.linalg}\label{numpy.linalg}

\begin{tabular}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.19\columnwidth}\raggedright
Command
\end{minipage} & \begin{minipage}[b]{0.75\columnwidth}\raggedright
Description
\end{minipage}\tabularnewline
\midrule
\begin{minipage}[t]{0.19\columnwidth}\raggedright
\lstinline!np.linalg.inv(A)!
\end{minipage} & \begin{minipage}[t]{0.75\columnwidth}\raggedright
For a 2-dimensional array \(A\). \lstinline!np.linalg.inv! returns the
inverse of \(A\). For example, for a \((2,2)\) array \(A\)

\begin{lstlisting}[language=Python]
np.linalg.inv(A).dot(A)
\end{lstlisting}

returns

\begin{lstlisting}[language=Python]
np.array( [1,0],
[0,1] ])
\end{lstlisting}

\end{minipage}\tabularnewline
\begin{minipage}[t]{0.19\columnwidth}\raggedright
\lstinline!np.linalg.eig(A)!
\end{minipage} & \begin{minipage}[t]{0.75\columnwidth}\raggedright
Returns a 1-dimensional array with all the eigenvalues of \$A\$ as well
as a 2-dimensional array with the eigenvectors as columns. For example,

\lstinline!eigvals,eigvecs = np.linalg.eig(A)!

returns the eigenvalues in \lstinline!eigvals! and the eigenvectors in
\lstinline!eigvecs!. \lstinline!eigvecs[:,i]! is the eigenvector of
\(A\) with eigenvalue of \lstinline!eigval[i]!.
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.19\columnwidth}\raggedright
\lstinline!np.linalg.solve(A,b)!
\end{minipage} & \begin{minipage}[t]{0.75\columnwidth}\raggedright
Constructs array \(x\) such that \lstinline!A.dot(x)! is equal to \(b\).
Theoretically should give the same answer as

\begin{lstlisting}[language=Python]
Ainv = np.linalg.inv(A)
x = Ainv.dot(b)
\end{lstlisting}

but numerically more stable.
\end{minipage}\tabularnewline
\bottomrule
\end{tabular}

\section{Pandas}\label{pandas}

\begin{tabular}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.14\columnwidth}\raggedright
Command
\end{minipage} & \begin{minipage}[b]{0.80\columnwidth}\raggedright
Description
\end{minipage}\tabularnewline
\midrule
\begin{minipage}[t]{0.14\columnwidth}\raggedright
pd.Series()
\end{minipage} & \begin{minipage}[t]{0.80\columnwidth}\raggedright
Constructs a Pandas Series Object from some specified data and/or index

\begin{lstlisting}[language=Python]
s1 = pd.Series([1,2,3])
s2 = pd.Series([1,2,3], index=['a','b','c'])
\end{lstlisting}

\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright
pd.DataFrame()
\end{minipage} & \begin{minipage}[t]{0.80\columnwidth}\raggedright
Constructs a Pandas DataFrame object from some specified data and/or
index, column names etc.

\begin{lstlisting}[language=Python]
d = {'a' : [1,2,3], 'b' : [4,5,6]}
df = pd.DataFrame(d)
\end{lstlisting}

or alternatively,

\begin{lstlisting}[language=Python]
a = [1,2,3]
b = [4,5,6]
df = pd.DataFrame(list(zip(a,b)), columns=['a','b'])
\end{lstlisting}

\end{minipage}\tabularnewline
\bottomrule
\end{tabular}
