\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage[unicode=true]{hyperref}
\hypersetup{
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{listings}
\usepackage{longtable,booktabs}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\date{}

\begin{document}

\section{Python cheatsheet}\label{python-cheatsheet}

\subsection{Functions}\label{functions}

\begin{longtable}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.17\columnwidth}\raggedright\strut
Command\strut
\end{minipage} & \begin{minipage}[b]{0.77\columnwidth}\raggedright\strut
Description\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.17\columnwidth}\raggedright\strut
\lstinline!*!\strut
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright\strut
multiplication operation: \lstinline!2*3! returns \lstinline!6!\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright\strut
\lstinline!**!\strut
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright\strut
power operation: \lstinline!2**3! returns \lstinline!8!\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright\strut
\lstinline!@!\strut
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright\strut
matrix multiplication:

\begin{lstlisting}[language=Python]
import numpy as np
A = np.array([[1,2,3]])
B = np.array([[3],[2],[1]])
A @ B
\end{lstlisting}

returns

\begin{lstlisting}[language=Python]
array([[10]])
\end{lstlisting}
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright\strut
\lstinline!lambda!\strut
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright\strut
Used for create anonymous one line functions of the form:

\begin{lstlisting}[language=Python]
f = lambda x,y: 5*x+y
\end{lstlisting}

The code after the lambda but before variables specifies the parameters.
The code after the colon tells python what object to return.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright\strut
\lstinline!def!\strut
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright\strut
The def command is used to create functions of more than one line:

\begin{lstlisting}[language=Python]
def g(x,y):
    """
    Docstring
    """
    ret = sin(x)
    return ret + y
\end{lstlisting}

The code immediately following \lstinline!def! names the function, in
this example \lstinline!g! . The variables in the parenthesis are the
parameters of the function. The remaining lines of the function are
denoted by tab indents. The return statement specifies the object to be
returned.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright\strut
\lstinline!len(iterable)!\strut
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright\strut
\lstinline!len! is a function that takes an iterable, such as a list,
tuple or numpy array and returns the number of items in that object. For
a numpy array, \lstinline!len! returns the length of the outermost
dimension

\begin{lstlisting}[language=Python]
len(np.zeros((5,4)))
\end{lstlisting}

returns \lstinline!5!.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright\strut
\lstinline!l = [a1,a2,...,an]!\strut
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright\strut
Constructs a list containing the objects \(a1,a2,...,an\). You can
append to the list using \lstinline!l.append()!. The \(ith\) element of
\(l\) can be accessed using \lstinline!l[i]!\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright\strut
\lstinline!t =(a1,a2,...,an)!\strut
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright\strut
Constructs a tuple containing the objects \(a1,a2,...,an\). The \(ith\)
element of \(t\) can be accessed using \lstinline!t[i]!\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright\strut
\lstinline!for a in iterable:!\strut
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright\strut
For loop used to perform a sequence of commands (denoted using tabs) for
each element in an iterable object such as a list, tuple, or numpy
array. An example code is

\begin{lstlisting}[language=Python]
l  = []
for i in [1,2,3]:
    l.append(i**2)
print(l)
\end{lstlisting}

prints \lstinline![1,4,9]!\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright\strut
\lstinline!if condition:!\strut
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright\strut
Performs code if a condition is met (using tabs). For example

\begin{lstlisting}[language=Python]
if x == 5:
    x = x**2
else:
    x = x**3
\end{lstlisting}

squares \(x\) if \(x\) is \(5\), otherwise cubes it.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright\strut
\lstinline!plt.plot(x,y,s =None)!\strut
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright\strut
The plot command is included in \lstinline!matplotlib.pyplot!. The plot
command is used to plot \(x\) versus \(y\) where \(x\) and \(y\) are
iterables of the same length. By default the plot command draws a line,
using the \(s\) argument you can specify type of line and color. For
example `-','- -`,':`,'o','x', and `-o' reprent line, dashed line,
dotted line, circles, x's, and circle with line through it respectively.
Color can be changed by appending `b','k','g' or `r', to get a blue,
black, green or red plot respectively. For example,

\begin{lstlisting}[language=Python]
import numpy as np
import matplotlib.pyplot as plt
x=np.linspace(0,10,100)
N=len(x)
v= np.cos(x)
plt.figure(1)
plt.plot(x,v,'-og')
plt.show()
plt.savefig('tom_test.eps')
\end{lstlisting}

plots the cosine function on the domain (0,10) with a green line with
circles at the points \(x,v\)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.17\columnwidth}\raggedright\strut
\lstinline!zip!\strut
\end{minipage} & \begin{minipage}[t]{0.77\columnwidth}\raggedright\strut
Make an iterator that aggregates elements from each of the iterables.

\begin{lstlisting}[language=Python]
x = [1, 2, 3]
y = [4, 5, 6]
zipped = zip(x, y)
list(zipped)
\end{lstlisting}

returns \lstinline![(1, 4), (2, 5), (3, 6)]!\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\subsection{Numpy Arrays}\label{numpy-arrays}

\begin{longtable}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.22\columnwidth}\raggedright\strut
Command\strut
\end{minipage} & \begin{minipage}[b]{0.72\columnwidth}\raggedright\strut
Description\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
\lstinline!np.array(object,dtype = None)!\strut
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright\strut
\lstinline!np.array! constructs a numpy array from an object, such as a
list or a list of lists. \lstinline!dtype! allows you to specify the
type of object the array is holding. You will generally note need to
specify the \lstinline!dtype!. Examples:

\begin{lstlisting}[language=Python]
np.array([1, 2, 3]) #creates 1 dim array of ints
np.array( [1,2,3.0] )#creates 1 dim array of floats
np.array( [ [1,2],[3,4] ]) #creates a 2 dim array
\end{lstlisting}
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
\lstinline!A[i1,i2,...,in]!\strut
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright\strut
Access a the element in numpy array A in with index i1 in dimension 1,
i2 in dimension 2, etc. Can use \lstinline!:! to access a range of
indices, where \lstinline!imin:imax! represents all \(i\) such that
\(imin \leq i < imax\). Always returns an object of minimal dimension.
For example,

\lstinline!A[:,2]!

returns the 2nd column (counting from 0) of A as a 1 dimensional array
and

\lstinline!A[0:2,:]!

returns the 0th and 1st rows in a 2 dimensional array.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
\lstinline!np.zeros(shape)!\strut
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright\strut
Constructs numpy array of shape shape. Here shape is an integer of
sequence of integers. Such as 3, (1,2),(2,1), or (5,5). Thus

\lstinline!np.zeros((5,5))!

Constructs an \(5\times 5\) array while

\lstinline!np.zeros(5,5)!

will throw an error.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
\lstinline!np.ones(shape)!\strut
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright\strut
Same as \lstinline!np.zeros! but produces an array of ones\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
\lstinline!np.linspace(a,b,n)!\strut
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright\strut
Returns a numpy array with \(n\) linearly spaced points between \(a\)
and \(b\). For example

\lstinline!np.linspace(1,2,10)!

returns

\begin{lstlisting}[language=Python]
array([ 1.        ,  1.11111111,  1.22222222,  1.33333333,
1.44444444, 1.55555556,  1.66666667,  1.77777778,
1.88888889,  2.        ])
\end{lstlisting}
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
\lstinline!np.eye(N)!\strut
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright\strut
Constructs the identity matrix of size \(N\). For example

\lstinline!np.eye(3)!

returns the \(3\times 3\) identity matrix:

\[\left(\begin{matrix}1&0&0\\0&1&0\\ 0&0&1\end{matrix}\right)\]\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
\lstinline!np.diag(a)!\strut
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright\strut
\lstinline!np.diag! has 2 uses. First if \lstinline!a! is a 2
dimensional array then \lstinline!np.diag! returns the principle
diagonal of the matrix. Thus

\lstinline!np.diag( [ [1,3], [5,6] ])!

returns \lstinline![1,6]!.

If \(a\) is a 1 dimensional array then \lstinline!np.diag! constructs an
array with \$a\$ as the principle diagonal. Thus,

\lstinline!np.diag([1,2])!

returns

\[\left(\begin{matrix}1&0\\0&2\end{matrix}\right)\]\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
\lstinline!np.random.rand(d0, d1, ..., dn)!\strut
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright\strut
Constructs a numpy array of shape \lstinline!(d0,d1,...,dn)! filled with
random numbers drawn from a uniform distribution between :math`(0,1).
For example, :python:np.random.rand(2,3)` returns

\begin{lstlisting}[language=Python]
array([[ 0.69060674,  0.38943021,  0.19128955],
[ 0.5419038 ,  0.66963507,  0.78687237]])
\end{lstlisting}
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
\lstinline!np.random.randn(d0, d1, ..., dn)!\strut
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright\strut
Same as \lstinline!np.random.rand(d0, d1, ..., dn)! except that it draws
from the standard normal distribution \(\mathcal N(0,1)\) rather than
the uniform distribution.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
\lstinline!A.T!\strut
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright\strut
Reverses the dimensions of an array (transpose). For example, if
\(x = \left(\begin{matrix} 1& 2\\3&4\end{matrix}\right)\) then
\lstinline!x.T! returns
\(\left(\begin{matrix} 1& 3\\2&4\end{matrix}\right)\)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
\lstinline!np.hstack(tuple)!\strut
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright\strut
Take a sequence of arrays and stack them horizontally to make a single
array. For example

\begin{lstlisting}[language=Python]
a = np.array(( [1,2,3] )
b = np.array( [2,3,4] )
np.hstack( (a,b) )
\end{lstlisting}

returns \lstinline![1,2,3,2,3,4]! while

\begin{lstlisting}[language=Python]
a = np.array( [[1],[2],[3]] )
b = np.array( [[2],[3],[4]] )
np.hstack((a,b))
\end{lstlisting}

returns
\(\left( \begin{matrix} 1&2\\2&3\\ 3&4 \end{matrix}\right)\)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
\lstinline!np.vstack(tuple)!\strut
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright\strut
Like \lstinline!np.hstack!. Takes a sequence of arrays and stack them
vertically to make a single array. For example

\begin{lstlisting}[language=Python]
a = np.array( [1,2,3] )
b = np.array( [2,3,4] )
np.hstack( (a,b) )
\end{lstlisting}

returns

\begin{lstlisting}[language=Python]
array( [ [1,2,3],
[2,3,4] ] )
\end{lstlisting}
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
\lstinline!np.amax(a, axis = None)!\strut
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright\strut
By default \lstinline!np.amax(a)! finds the maximum of all elements in
the array \(a\). Can specify maximization along a particular dimension
with axis. If

\lstinline!a = np.array( [ [2,1], [3,4] ]) #creates a 2 dim array!

then

\lstinline!np.amax(a,axis = 0) #maximization along row (dim 0)!

returns \lstinline!array([3,4])! and

\lstinline!np.amax(a, axis = 1) #maximization along column (dim 1)!

returns \lstinline!array([2,4])!\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
\lstinline!np.amin(a, axis = None)!\strut
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright\strut
Same as \lstinline!np.amax! except returns minimum element.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
\lstinline!np.argmax(a, axis = None)!\strut
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright\strut
Performs similar function to np.amax except returns index of maximal
element. By default gives index of flattened array, otherwise can use
axis to specify dimension. From the example for np.amax

\begin{lstlisting}[language=Python]
np.amax(a,axis = 0) #maximization along row (dim 0)
\end{lstlisting}

returns \lstinline!array([1,1])! and

\begin{lstlisting}[language=Python]
np.amax(a, axis = 1) #maximization along column (dim 1)
\end{lstlisting}

returns \lstinline!array([0,1])!\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
\lstinline!np.argmin(a, axis =None)!\strut
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright\strut
Same as \lstinline!np.argmax! except finds minimal index.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
\lstinline!np.dot(a,b)! or \lstinline!a.dot(b)!\strut
\end{minipage} & \begin{minipage}[t]{0.72\columnwidth}\raggedright\strut
Returns an array equal to the dot product of \(a\) and \(b\). For this
operation to work the innermost dimension of \(a\) must be equal to the
outermost dimension of \(b\). If \(a\) is a \((3,2)\) array and \(b\) is
a \((2)\) array then \lstinline!np.dot(a,b)! is valid. If \(b\) is a
\((1,2)\) array then the operation will return an error.\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\subsection{numpy.linalg}\label{numpy.linalg}

\begin{longtable}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.19\columnwidth}\raggedright\strut
Command\strut
\end{minipage} & \begin{minipage}[b]{0.75\columnwidth}\raggedright\strut
Description\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.19\columnwidth}\raggedright\strut
\lstinline!np.linalg.inv(A)!\strut
\end{minipage} & \begin{minipage}[t]{0.75\columnwidth}\raggedright\strut
For a 2-dimensional array \(A\). \lstinline!np.linalg.inv! returns the
inverse of \(A\). For example, for a \((2,2)\) array \(A\)

\begin{lstlisting}[language=Python]
np.linalg.inv(A).dot(A)
\end{lstlisting}

returns

\begin{lstlisting}[language=Python]
np.array( [1,0],
[0,1] ])
\end{lstlisting}
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.19\columnwidth}\raggedright\strut
\lstinline!np.linalg.eig(A)!\strut
\end{minipage} & \begin{minipage}[t]{0.75\columnwidth}\raggedright\strut
Returns a 1-dimensional array with all the eigenvalues of \$A\$ as well
as a 2-dimensional array with the eigenvectors as columns. For example,

\lstinline!eigvals,eigvecs = np.linalg.eig(A)!

returns the eigenvalues in \lstinline!eigvals! and the eigenvectors in
\lstinline!eigvecs!. \lstinline!eigvecs[:,i]! is the eigenvector of
\(A\) with eigenvalue of \lstinline!eigval[i]!.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.19\columnwidth}\raggedright\strut
\lstinline!np.linalg.solve(A,b)!\strut
\end{minipage} & \begin{minipage}[t]{0.75\columnwidth}\raggedright\strut
Constructs array \(x\) such that \lstinline!A.dot(x)! is equal to \(b\).
Theoretically should give the same answer as

\begin{lstlisting}[language=Python]
Ainv = np.linalg.inv(A)
x = Ainv.dot(b)
\end{lstlisting}

but numerically more stable.\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\subsection{Pandas}\label{pandas}

\begin{longtable}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.14\columnwidth}\raggedright\strut
Command\strut
\end{minipage} & \begin{minipage}[b]{0.80\columnwidth}\raggedright\strut
Description\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.14\columnwidth}\raggedright\strut
pd.Series()\strut
\end{minipage} & \begin{minipage}[t]{0.80\columnwidth}\raggedright\strut
Constructs a Pandas Series Object from some specified data and/or index

\begin{lstlisting}[language=Python]
s1 = pd.Series([1,2,3])
s2 = pd.Series([1,2,3], index=['a','b','c'])
\end{lstlisting}
\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.14\columnwidth}\raggedright\strut
pd.DataFrame()\strut
\end{minipage} & \begin{minipage}[t]{0.80\columnwidth}\raggedright\strut
Constructs a Pandas DataFrame object from some specified data and/or
index, column names etc.

\begin{lstlisting}[language=Python]
d = {'a' : [1,2,3], 'b' : [4,5,6]}
df = pd.DataFrame(d)
\end{lstlisting}

or alternatively,

\begin{lstlisting}[language=Python]
a = [1,2,3]
b = [4,5,6]
df = pd.DataFrame(list(zip(a,b)), columns=['a','b'])
\end{lstlisting}
\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

\end{document}
